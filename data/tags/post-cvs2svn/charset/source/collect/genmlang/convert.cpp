



#ifdef _WIN32
#pragma warning( disable : 4710 ) // Silly inline warning level 4 warning
//#pragma warning( push )
#pragma warning( disable : 4786 ) // disable the warning "identifier was truncated to '255' characters in the debug information" generated by STL
//#pragma warning( disable : 4100 4663 4511 4512 4018 ) // Silly warning level 4 warnings
#endif // _WIN32

#include "convert.h"






// OLE safe release (Win32)

#define safe_release(ptr) {if (ptr){ptr -> Release();ptr = NULL; }}

// global for enum proc interface
static map<cp_id, encoding_info_ptr>* p_map_encoding_info;
static vector<cp_id>* p_encodings;

// global for codepage names for CodePageEnumProc
static map<cp_id, std::string> misc_cp_names;

void load_misc_cp_names()
{
    misc_cp_names[10000] = "(MAC - Roman)";
    misc_cp_names[10001] = "(MAC - Japanese)";
    misc_cp_names[10002] = "(MAC - Traditional Chinese Big5)";
    misc_cp_names[10003] = "(MAC - Korean)";
    misc_cp_names[10004] = "(MAC - Arabic)";
    misc_cp_names[10005] = "(MAC - Hebrew)";
    misc_cp_names[10006] = "(MAC - Greek I)";
    misc_cp_names[10007] = "(MAC - Cyrillic)";
    misc_cp_names[10008] = "(MAC - Simplified Chinese GB 2312)";
    misc_cp_names[10010] = "(MAC - Romania)";
    misc_cp_names[10017] = "(MAC - Ukraine)";
    misc_cp_names[10029] = "(MAC - Latin II)";
    misc_cp_names[10079] = "(MAC - Icelandic)";
    misc_cp_names[10081] = "(MAC - Turkish)";
    misc_cp_names[10082] = "(MAC - Croatia)";
    misc_cp_names[437] = "MS-DOS United States";
    misc_cp_names[708] = "Arabic (ASMO 708)";
    misc_cp_names[709] = "Arabic (ASMO 449+, BCON V4)";
    misc_cp_names[710] = "Arabic (Transparent Arabic)";
    misc_cp_names[720] = "Arabic (Transparent ASMO)";
    misc_cp_names[737] = "Greek (formerly 437G)";
    misc_cp_names[775] = "Baltic";
    misc_cp_names[850] = "MS-DOS Multilingual (Latin I)";
    misc_cp_names[852] = "MS-DOS Slavic (Latin II)";
    misc_cp_names[855] = "IBM Cyrillic (primarily Russian)";
    misc_cp_names[857] = "IBM Turkish";
    misc_cp_names[860] = "MS-DOS Portuguese";
    misc_cp_names[861] = "MS-DOS Icelandic";
    misc_cp_names[862] = "Hebrew";
    misc_cp_names[863] = "MS-DOS Canadian-French";
    misc_cp_names[864] = "Arabic";
    misc_cp_names[865] = "MS-DOS Nordic";
    misc_cp_names[866] = "MS-DOS Russian (former USSR)";
    misc_cp_names[869] = "IBM Modern Greek";
    misc_cp_names[874] = "Thai";
    misc_cp_names[932] = "Japan";
    misc_cp_names[936] = "Chinese (PRC, Singapore)";
    misc_cp_names[949] = "Korean";
    misc_cp_names[950] = "Chinese (Taiwan; Hong Kong SAR, PRC)";
    misc_cp_names[1200] = "Unicode (BMP of ISO 10646)";
    misc_cp_names[1250] = "Windows 3.1 Eastern European";
    misc_cp_names[1251] = "Windows 3.1 Cyrillic";
    misc_cp_names[1252] = "Windows 3.1 Latin 1 (US, Western Europe)";
    misc_cp_names[1253] = "Windows 3.1 Greek";
    misc_cp_names[1254] = "Windows 3.1 Turkish";
    misc_cp_names[1255] = "Hebrew";
    misc_cp_names[1256] = "Arabic";
    misc_cp_names[1257] = "Baltic";
    misc_cp_names[1258] = "Latin 1 (ANSI)";
    misc_cp_names[20000] = "CNS - Taiwan";
    misc_cp_names[20001] = "TCA - Taiwan";
    misc_cp_names[20002] = "Eten - Taiwan";
    misc_cp_names[20003] = "IBM5550 - Taiwan";
    misc_cp_names[20004] = "TeleText - Taiwan";
    misc_cp_names[20005] = "Wang - Taiwan";
    misc_cp_names[20127] = "US ASCII";
    misc_cp_names[20261] = "T.61";
    misc_cp_names[20269] = "ISO-6937";
    misc_cp_names[20866] = "Ukrainian - KOI8-U";
    misc_cp_names[21027] = "Ext Alpha Lowercase";
    misc_cp_names[21866] = "Russian - KOI8";
    misc_cp_names[28591] = "ISO 8859-1 Latin I";
    misc_cp_names[28592] = "ISO 8859-2 Eastern Europe";
    misc_cp_names[28593] = "ISO 8859-3 Turkish";
    misc_cp_names[28594] = "ISO 8859-4 Baltic";
    misc_cp_names[28595] = "ISO 8859-5 Cyrillic";
    misc_cp_names[28596] = "ISO 8859-6 Arabic";
    misc_cp_names[28597] = "ISO 8859-7 Greek";
    misc_cp_names[28598] = "ISO 8859-8 Hebrew";
    misc_cp_names[28599] = "ISO 8859-9 Latin Alphabet No.5";
    misc_cp_names[29001] = "Europa 3";
    misc_cp_names[1361] = "Korean (Johab)";
    misc_cp_names[1047] = "IBM EBCDIC - Latin-1/Open System";
    misc_cp_names[20261] = "T.61";
    misc_cp_names[20269] = "ISO 6937 Non-spacing Accent";
    misc_cp_names[20924] = "IBM EBCDIC - Latin-1/Open System(1047 + Euro)";
    misc_cp_names[20932] = "JIS X 0208-1990 & 0212-1990";
    misc_cp_names[20936] = "Simplified Chinese GB2312";
    misc_cp_names[21027] = "Ext Alpha Lowercase";
    misc_cp_names[855] = "OEM - Cyrillic";
    misc_cp_names[858] = "OEM - Multilingual Latin 1 + Euro";
    misc_cp_names[860] = "OEM - Portuguese";
    misc_cp_names[863] = "OEM - Canadian French";
    misc_cp_names[864] = "OEM - Arabic";
    misc_cp_names[865] = "OEM - Nordic";
}

BOOL CALLBACK CodePageEnumProc(LPTSTR lpCodePageString)
{
    UINT cp;
    
    sscanf(lpCodePageString,"%d", &cp);
    
    map<cp_id, encoding_info_ptr>::iterator iinf = p_map_encoding_info->find(cp);
    
    if ( iinf == p_map_encoding_info->end() )
    {
        encoding_info_ptr enc_info = new struct _encoding_info;
        strcpy(enc_info->web_charset_name, "Not applicable");

        map<cp_id, std::string>::iterator iname = misc_cp_names.find(cp);

        if ( iname != misc_cp_names.end() ) {
           strcpy(enc_info->charset_description, (*iname).second.c_str());
        }
        else {
           strcpy(enc_info->charset_description, "No description available");
        }
        
        (*p_encodings).push_back( cp );
        (*p_map_encoding_info)[cp] = enc_info;
    }
    
    return TRUE;
}

// get encodings supported by the system
int get_supported_encodings(vector<cp_id>& encodings, map<cp_id, encoding_info_ptr>& map_encoding_info)
{
#ifdef _WIN32
    IMultiLanguage2 *multilanguage;
    IEnumCodePage *mlang_enum_codepage;
    IMLangConvertCharset* mlang_convert_charset;
    
    cp_id cnum = 0;
    PMIMECPINFO mime_cp_info;
    unsigned long count_cp_info;
    HRESULT hr;
    char description[100];
    char web_charset_name[100];
    UINT src_len;
    UINT dst_len;
    
    hr = CoInitialize(NULL);
    
    if (FAILED(hr)) {
        fprintf(stderr, "Error initializing OLE subsystem: %d\n", hr);
        exit(1);
    }
    
    hr = CoCreateInstance(
        CLSID_CMultiLanguage,     //REFCLSID rclsid,     //Class identifier (CLSID) of the object
        NULL,                     //LPUNKNOWN pUnkOuter, //Pointer to controlling IUnknown
        CLSCTX_INPROC_SERVER,     //DWORD dwClsContext,  //Context for running executable code
        IID_IMultiLanguage2 ,     //REFIID riid,         //Reference to the identifier of the interface
        (void**) &multilanguage   //LPVOID * ppv         //Address of output variable that receives 
        // the interface pointer requested in riid
        );
    
    if ( NULL == multilanguage ) {
        DWORD err = GetLastError();
        fprintf(stderr, "Error initializing MLang subsystem: %ul (%08X)\n", err, hr);
        return -1;
    }
    
    hr = multilanguage->EnumCodePages(
        MIMECONTF_VALID_NLS,  //    DWORD grfFlags,
        MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),   // [in]  LANGID LangId,
        &mlang_enum_codepage    //    IEnumCodePage **ppEnumCodePage
        );
    
    hr = multilanguage->CreateConvertCharset(1200, 1252, 0, &mlang_convert_charset);
    
    hr = multilanguage->GetNumberOfCodePageInfo(&cnum);
    
    mime_cp_info = (PMIMECPINFO)CoTaskMemAlloc(sizeof(MIMECPINFO)*cnum);
    
    hr = mlang_enum_codepage->Next(cnum, mime_cp_info, &count_cp_info);
    
    for(uint32_t i = 0; i < count_cp_info; i++)
    {
        
        dst_len = sizeof(description);
        src_len = wcslen(mime_cp_info[i].wszDescription);
        
        mlang_convert_charset->DoConversionFromUnicode(mime_cp_info[i].wszDescription,
            &src_len, description, &dst_len);
        description[dst_len] = '\0';
        
        dst_len = sizeof(web_charset_name);
        src_len = wcslen(mime_cp_info[i].wszWebCharset);
        
        mlang_convert_charset->DoConversionFromUnicode(mime_cp_info[i].wszWebCharset,
            &src_len, web_charset_name, &dst_len);
        web_charset_name[dst_len] = '\0';
        
        // printf("\"%s\", \"%s\", %d\n", description, web_charset_name, mime_cp_info[i].uiCodePage);
        
        encoding_info_ptr pEncoding = new struct _encoding_info;
        strcpy(pEncoding->web_charset_name, web_charset_name);
        strcpy(pEncoding->charset_description, description);
        
        encodings.push_back( mime_cp_info[i].uiCodePage );
        map_encoding_info[mime_cp_info[i].uiCodePage] = pEncoding;
        
    }
    
    safe_release(multilanguage);
    safe_release(mlang_enum_codepage);
    safe_release(mlang_convert_charset);
    
    CoTaskMemFree(mime_cp_info);
    
    CoUninitialize();
    
    // now get any additional ones supported by the wctomb/bmtowc APIs
    
    // global for the enum proc
    p_map_encoding_info = &map_encoding_info;
    p_encodings = &encodings;
    
    // init names
    load_misc_cp_names();

    EnumSystemCodePages(CodePageEnumProc, CP_INSTALLED);
    
#endif // _WIN32
    
    return 0;
}

converter::converter(cp_id cp, encoding_info_ptr enc_info)
{
    m_multilanguage = 0;
    m_hr = 0;
    m_err = 0;
    m_enc_num = cp;
    m_enc_info = enc_info;
    
#ifdef _WIN32
    m_hr = CoInitialize(NULL);
    
    if (FAILED(m_hr)) {
        m_err = GetLastError();
        fprintf(stderr, "Error initializing OLE subsystem: %d\n", m_err);
        return ;
    }
    
    m_hr = CoCreateInstance(
        CLSID_CMultiLanguage,      //REFCLSID rclsid,     //Class identifier (CLSID) of the object
        NULL,                      //LPUNKNOWN pUnkOuter, //Pointer to controlling IUnknown
        CLSCTX_INPROC_SERVER,      //DWORD dwClsContext,  //Context for running executable code
        IID_IMultiLanguage2,       //REFIID riid,         //Reference to the identifier of the interface
        (void**) &m_multilanguage  //LPVOID * ppv         //Address of output variable that receives 
        // the interface pointer requested in riid
        );
    
    if ( NULL == m_multilanguage ) {
        m_err = GetLastError();
        fprintf(stderr, "Error initializing MLang subsystem: %ul (%08X)\n", m_err, m_hr);
        return ;
    }
    
#endif _WIN32
    
}

converter::~converter()
{
#ifdef _WIN32
    safe_release(m_multilanguage);
    
    CoUninitialize();
#endif
}

size_t converter::from_unicode(char* target, char* target_limit, const UChar* source, const UChar* source_limit, unsigned int flags)
{
#ifdef _WIN32
    
    UINT srcSize, targ_size_bytes;
    
    srcSize = source_limit - source;
    targ_size_bytes = target_limit - target;
    
    // Setting this to 0 before each conversion means that we lose the conversion context
    DWORD mode_flags = 0;
    m_hr = m_multilanguage->ConvertStringFromUnicodeEx(   &mode_flags,
        m_enc_num,
        (WCHAR*) source, 
        &srcSize,
        target, 
        &targ_size_bytes,
        flags,
        L"");
    
    if ( *source && 1 == targ_size_bytes && 0 == *target )
        targ_size_bytes = 0;
    
    return (size_t) targ_size_bytes;
    
#endif // _WIN32
}

size_t converter::to_unicode(UChar* target, UChar* target_limit, const char* source, const char* source_limit)
{
#ifdef _WIN32
    
    UChar unibuffTest[16];

    UINT src_size_bytes, targ_size;
    
    src_size_bytes = source_limit - source;
    targ_size = target_limit - target;
    
    // Setting this to 0 before each conversion means that we lose the conversion context
    DWORD mode_flags = 0;
    m_hr = m_multilanguage->ConvertStringToUnicodeEx(  &mode_flags,
        m_enc_num,
        (char*)source,
        &src_size_bytes,
        target,
        &targ_size,
        0,
        NULL);
    
    if ( *source && 1 == targ_size && 0 == *target )
    {
        targ_size = 0;
    }

    int convertedSize = MultiByteToWideChar(m_enc_num, 0, source, src_size_bytes, unibuffTest, 16);
    if (source[0] != 0x3f && source[0] != 0x6f) {
        if (convertedSize > 0 && convertedSize != targ_size) {
//            printf("Consistency warning! %X %X %X %X isn't converted by both APIs\n", (uint32_t)source[0], (uint32_t)source[1], (uint32_t)source[2], (uint32_t)source[3]);
        }
        else if (convertedSize > 0 && unibuffTest[0] != target[0]) {
            printf("\nConsistency error! %X %X goes to %04X C API or %04X COM API", (uint8_t)source[0], (uint8_t)source[1], unibuffTest[0], target[0]);
        }
    }
    /* The last two parameters don't work right now. */
/*    mode_flags = 0;
    m_hr = m_multilanguage->ConvertStringToUnicodeEx(  &mode_flags,
        m_enc_num,
        (char*)source,
        &src_size_bytes,
        target,
        &targ_size,
        MLCONVCHARF_USEDEFCHAR,
        L"\xfffd");*/

#endif // _WIN32
    
    
    return (size_t) (targ_size);
}

string
converter::get_default_char(UChar *default_uchar)
{
    char buff1[80];
    char buff2[80];
    UChar ubuff[8];
    UChar* source;
    size_t num_bytes1, num_bytes2;
    
    *default_uchar = 0;

    for (UChar u = 0x100 ; u < MAX_UNICODE_VALUE ; u++ )
    {
        ubuff[0] = u;
        source = ubuff;
        
        // use converter's own default char
        num_bytes1 = from_unicode(buff1, buff1+80, source, source+1, CONVERTER_USE_SUBST_CHAR);
        
        // do not return a default char - string unconvertable characters
        num_bytes2 = from_unicode(buff2, buff2+80, source, source+1);
        
        if (0 == num_bytes2 && num_bytes1 != 0 )
        {
            buff1[num_bytes1] = 0;

            ubuff[0] = u;
            source = ubuff;
            num_bytes1 = to_unicode(source, source+1, buff1, NULL);
            *default_uchar = ubuff[0];
            break;
        }
    }
    
    return (string) buff1;
}

int 
converter::get_cp_info(cp_id cp, cp_info& cp_inf)
{

    strcpy(cp_inf.default_char, get_default_char(&cp_inf.default_uchar).c_str());
    return 0;
}