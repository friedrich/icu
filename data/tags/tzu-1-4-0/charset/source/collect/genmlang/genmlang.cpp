/*
*******************************************************************************
*
*   Copyright (C) 2000, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*
*  Modification History:
*
*   Date        Name        Description
*   15-Jul-2001 Ed Batutis  Created.
*
* genmlang.cpp : Generate ucm file using Microsoft IMultiLang
* 
* genmlang [path_to_unicode_data_txt]
*
*
* Win32 Notes:
*   This program requires MSVC plus the Platform SDK from April 2000 or later.
*   Also required is MLANG.DLL version 5.5 or later which is installed
*   with IE 5.5. The MLANG.DLL that comes with Win2K will not work.
*/

// todo:
// Deal with surrogates and UChar32 - currently Windows does not support
// gb18030 or converters with surrogates, so no big hurry. Windows XP will.
// - eb

#include <stdio.h>
#include <time.h>

#ifdef _WIN32
#pragma warning( disable : 4710 ) // Silly inline warning level 4 warning
//#pragma warning( push )
#pragma warning( disable : 4786 ) // disable the warning "identifier was truncated to '255' characters in the debug information" generated by STL
//#pragma warning( disable : 4100 4663 4511 4512 4018 ) // Silly warning level 4 warnings
#endif // _WIN32

#include "convert.h"

void 
save_byte_range(byte_info_ptr byte_info, string str, size_t offset, size_t size);


// utility function prototypes

void gen_cp_strings(byte_info_ptr byte_range_ptr, vector<string>& cp_data);

// This is where UnicodeData.txt is installed on my system
// Use a command line argument to over-ride it.

/*
#define DEFAULT_UNICODE_DATA_FILENAME "\\projects\\lcu\\srcpc\\icu\\data\\unidata\\UnicodeData.txt"

int load_unicode(vector<UChar32>& v_unicode,
                 char* filename = DEFAULT_UNICODE_DATA_FILENAME, 
                 int f_include_pua = 1);
*/
//char *parse_unicode_char_name(char *line);

string gen_hex_escape(string str);

void print_icu_state(byte_info_ptr info, FILE* fp);
const char *print_icu_features(char *featureBuf, int32_t features, char* code_page_str);
UBool print_ranges(int8_t arr[], size_t len, int print_threshold, int level, FILE* fp);

// UCM file info

#ifdef _WIN32
#define OS_VENDOR "windows"
#define OS_VARIANT "2000"
#define OS_INTERFACE "IMultiLanguage 5.50.4522.1800"
#endif // _WIN32

FILE *open_ucm(char* p_ucm_filename);
char* gen_ucm_filename(cp_id cp);

void emit_ucm_header(FILE* fp,
                     cp_id cp,
                     _encoding_info* encoding_info,
                     const cp_info& cp_inf,
                     int32_t featureSet);

void emit_ucm_tail(FILE* fp);

const char *getPremadeStateTable(cp_id cp);

// Default reverse fallback character to Unicode
#define DEFAULT_RFB_CHAR 0x30FB

#define IS_PUA(unicode_char_32) (0xE000 <= unicode_char_32 && unicode_char_32 <= 0xF8FF)

typedef enum {
    ASCII           = 0x01, // Normal vanilla ASCII ISO-646
    VASCII          = 0x02, // Changed the standard mapping of 0x20-0x7E, like the dollar sign.
    EBCDIC          = 0x04, // Normal vanilla EBCDIC
    EBCDIC_NLLF     = 0x08, // Swapped the newline and linefeed on EBCDIC (os/390)
    PRIVATE_USE     = 0x10, // Uses the private use area of Unicode
    VCONTROLS       = 0x20, // Mapped the ISO control codes to something else like graphical characters
    VSUB            = 0x40, // Rotated the ISO control codes 1a->7f, 7f->1c, 1c->1a
    ERR_UNKNOWN     = 0x8000    // Didn't collect it properly
} EncodingFeature;

int32_t getEncodingFeatures(map<UChar32, string> uni_to_cp, UBool used_PUA);


int main(int argc, char* argv[])
{
//    vector<UChar32> v_unicode;
    vector<cp_id> encodings;
    map<cp_id, encoding_info_ptr> map_encoding_info;
//    int num;
//    int v_unicode_size;
    char* p_converter_match = 0;
    cp_id converter_match = -1;

    argc--; argv++;
/*
    // load all defined Unicode characters

    if ( argc )
        num = load_unicode(v_unicode, *argv);
    else
        num = load_unicode(v_unicode);
    if ( 0 == num ) 
    {
        fputs("Error loading Unicode data file", stderr);
        return 1;
    }

//    v_unicode_size = v_unicode.size();
*/

    // optional argument is a simple match string for converters to generate

    p_converter_match = *argv;

    if ( p_converter_match )
    {
       int i_cp = -1;
       sscanf(p_converter_match, "%d", &i_cp);
       converter_match = i_cp;
    }

    // query the OS for a list of encodings to analyze
    
    if ( get_supported_encodings(encodings, map_encoding_info) )
        return 1;
    
    for (int i = 0 ; i < encodings.size() ; i++ ) 
    {
        // lookup tables 
        map<UChar32, string> uni_to_cp;
        map<UChar32, vector<string> > cp_to_uni_by_uni;
        map<string, vector<UChar32> > cp_to_uni_by_cp;
        // 
        byte_info byte_range[MAX_BYTE_LEN];
        cp_id cp = encodings[i];
        int min_byte_size = 0xffff;
        int max_byte_size = 0;
        UBool used_PUA = FALSE;
        
        memset(byte_range, 0, MAX_BYTE_LEN * sizeof(byte_info));
        
        encoding_info_ptr encoding_info = map_encoding_info[cp];
        
        // look for match for converter name/code page number on the command line
        if ( p_converter_match &&
               ( 0 == strstr(encoding_info->web_charset_name, p_converter_match) &&
                 0 == strstr(encoding_info->charset_description, p_converter_match) &&
                 cp != converter_match ) )
        {
            continue;
        }

        // skip encodings we don't want to make a ucm file for
        if ( encoding_info->web_charset_name[0] == '_' ||   // pseudo-charsets used for auto-detect
            strstr(encoding_info->web_charset_name, "2022") ||
            cp == 52936 ||  // hz-gb-2312
            cp == 1200 ||   // utf-16
            cp == 1201 ||   // utf-16BE
            cp == 65000 ||  // utf-7
            cp == 65001 ||  // utf-8
            cp == 50000 ||  // x-user-defined
            cp == 57006 ||  // x-iscii-as
            cp == 57003 ||  // x-iscii-be
            cp == 57002 ||  // x-iscii-de
            cp == 57010 ||  // x-iscii-gu
            cp == 57008 ||  // x-iscii-ka
            cp == 57009 ||  // x-iscii-ma
            cp == 57007 ||  // x-iscii-or
            cp == 57011 ||  // x-iscii-pa
            cp == 57004 ||  // x-iscii-ta
            cp == 57005     // x-iscii-te
            )
        {
            fprintf(stdout, "\tSkipping %s (%s) (windows-%d)\n", encoding_info->charset_description, encoding_info->web_charset_name, cp);
            continue;
        }
        
        // create a system Unicode <-> cp converter
        
        converter cnv = converter(cp, encoding_info);
        
        if ( 0 == cnv.get_status() )
        {
            fprintf(stdout, "%d - %s - %s, ", cp, encoding_info->charset_description, encoding_info->web_charset_name);
            //fprintf(stdout, "%s, ", encoding_info->web_charset_name);
        }
        else
        {
            fprintf(stderr, "Failed opening converter for code page %d: %s (%s)", cp, encoding_info->charset_description, encoding_info->web_charset_name);
            continue;
        }
        
        // Unicode to code page loop
        
        for (UChar32 unicode_char = 0 ; unicode_char < MAX_UNICODE_VALUE ; unicode_char++ )
        {
//            UChar32 unicode_char;
            UChar source_uni[2];
            char cp[80];
            size_t len_uni = 0;
            size_t targ_size;
            
//            unicode_char = v_unicode[j];
            
            UTF16_APPEND_CHAR_SAFE(source_uni, len_uni, sizeof(source_uni), unicode_char);
            
            targ_size = cnv.from_unicode(cp, cp+sizeof(cp), source_uni, source_uni+len_uni);
            
            if ( targ_size ) 
            {
                string scp(cp, targ_size);
                
                uni_to_cp[unicode_char] = scp;
                
                if ( targ_size > MAX_BYTE_LEN )
                {
                    fprintf(stderr,"targ_size overflow! Uni: ");
                    for (int u = 0 ; u < len_uni ; u++)
                        fprintf(stderr, "%04X ", source_uni[u]);
                    fputs("cp: ", stderr);
                    for (u = 0 ; u < targ_size ; u++ )
                        fprintf(stderr, "%02X ", ((unsigned char) cp[u]));
                    fputs("\n", stderr);
                }
                else {
                    save_byte_range(&byte_range[0], scp, 0, targ_size);
                    if (IS_PUA(unicode_char)) {
                        used_PUA = TRUE;
                    }
                }
                
                if ( targ_size < min_byte_size )
                    min_byte_size = targ_size;
                
                if ( targ_size > max_byte_size )
                    max_byte_size = targ_size;
                
            }
            
        } // unicode chars
        
        fprintf(stdout, "%d-%d bytes ", min_byte_size, max_byte_size);
        
        // generate code page char iterator
        
        vector<string> cp_data;
        
        gen_cp_strings(byte_range, cp_data);
        
        // code page to Unicode loop
        
        for ( int j = 0 ; j < cp_data.size() ; j++ )
        {
            UChar32 uni32;
            UChar unibuff[16];
            char buff[MAX_BYTE_LEN + 4];
            const char* source = buff;
            size_t targ_size;
            
            // odd behavior of the MLang converter from IE5.5: some characters
            // do not convert properly if they are alone in the buffer. Padding with
            // 2 or more NULL bytes seems to make the converter work properly. MLang
            // will simply drop the characters without the NULL padding.
            
            memset(buff, 0, sizeof(buff));
            memcpy(buff, cp_data[j].data(), cp_data[j].size());
            
            memset(unibuff, 0, sizeof(unibuff));
            
            targ_size = cnv.to_unicode(unibuff, unibuff+(sizeof(unibuff)/sizeof(UChar)), source, source+sizeof(buff));
            
            // ignore trailing NULLs...
            
            while (targ_size) 
            {
                if ( unibuff[targ_size-1] )
                    break;
                
                targ_size--;
            }
            
            // ... unless the NULL is supposed to be there
            if ( 0 == *source && 0 == targ_size )
                targ_size = 1;
            
            uni32 = (UChar32) unibuff[0];
            
            if ( targ_size ) 
            {
                
                if ( targ_size > 1 ) 
                {
                    UTF16_GET_CHAR_SAFE(unibuff, 0, 0, 2, uni32, TRUE);
                }
                
                if (IS_PUA(uni32)) {
                    used_PUA = TRUE;
                }
//                if (cp_to_uni_by_uni[uni32].size() > 0) {
//                    fprintf(stderr, "Double mapping %X\n", uni32);
//                }
                cp_to_uni_by_uni[uni32].push_back(cp_data[j]);
                
                cp_to_uni_by_cp[cp_data[j]].push_back(uni32);
            }
            
        }
        
        // generate ucm file
        
        char* p_ucm_filename = gen_ucm_filename(cp);
        if (uni_to_cp.size() < 0x7f) {
            fprintf(stdout, "Incomplete mapping.  Not generating %s\n", p_ucm_filename);
            continue;
        }
        FILE *fp = open_ucm(p_ucm_filename);
        cp_info cp_inf;
        
        fprintf(stdout, "-> %s\n", p_ucm_filename);
        
        // get some converter info from the converter itself
        
        cnv.get_cp_info(cp, cp_inf);
        
        // other converter info has been generated here
        
        cp_inf.min_byte_size = min_byte_size;
        cp_inf.max_byte_size = max_byte_size;
        cp_inf.byte_info = byte_range;
        
        int32_t features = getEncodingFeatures(uni_to_cp, used_PUA);
        emit_ucm_header(fp, cp, encoding_info, cp_inf, features);
        
        for ( UChar32 uni = 0 ; uni < MAX_UNICODE_VALUE ; uni++ )
        {
//            UChar32 uni;
            bool f_fallback;
            string cp_data_uni_to_cp;
            
//            uni = v_unicode[j];
            
            map<UChar32, string>::iterator iter_cp = uni_to_cp.find(uni);
            
            // check for primary or fallback mapping (uni -> code page)
            if ( iter_cp != uni_to_cp.end() ) 
            {
                // is it a primary mapping or a fallback?
                cp_data_uni_to_cp = (*iter_cp).second;
                
                vector<UChar32> uni_vector = cp_to_uni_by_cp[cp_data_uni_to_cp];
                if (uni_vector.size() < 1)
                {
                    fprintf(stderr, "Missing mapping for <U%04X>\n", uni);
                }
                else if (uni_vector.size() > 1)
                {
                    fprintf(stdout, "Too many mappings for <U%04X> %s\n", uni, gen_hex_escape(cp_data_uni_to_cp).c_str());
                }
                else
                {
                    f_fallback = (uni_vector[0] != uni);
                    fprintf(fp, "<U%04X> %s |%d\n", uni, gen_hex_escape(cp_data_uni_to_cp).c_str(), f_fallback);
                }
            }
            
            // check for 'reverse fallback' mapping (code page -> uni)
            
            if (uni != cp_inf.default_uchar && uni != DEFAULT_RFB_CHAR)
            {
                map<UChar32, vector<string> >::iterator iter_cp_to_uni = cp_to_uni_by_uni.find(uni);
        
                if ( iter_cp_to_uni != cp_to_uni_by_uni.end() )
                {
                    vector<string>::iterator cp_itr = cp_to_uni_by_uni[uni].begin();
                    while (cp_itr != cp_to_uni_by_uni[uni].end())
                    {
                        string cpdataCP2Uni = (*cp_itr);

                        if ( cpdataCP2Uni.compare(cp_data_uni_to_cp) )
                        {
                            string default_char = cp_inf.default_char;
                            fprintf(fp, "<U%04X> %s |3\n", uni, gen_hex_escape(cpdataCP2Uni).c_str());
                        }
                        cp_itr++;
                    }
                }
            }
        }
        
        emit_ucm_tail(fp);
        fclose(fp);
        
   } // encodings
   
   return 0;
}

// load defined Unicode characters into a vector
/*
int load_unicode(vector<UChar32>& v_unicode, char* filename, int f_include_pua) {
    FILE *uf;
    char line[1024];
    char *parsedLine;
    UChar32 uni_char;
    int ret = 0;
    int cnt = 0;
    
    uf = fopen(filename, "rt");
    
    if ( 0 == uf || ((FILE*)-1) == uf ) {
        fputs("error opening unicode data file", stderr);
        exit(0);
    }
    
    while ( fgets(line, sizeof(line), uf) ) {
        int scanned;

        parsedLine = strtok(line, ";");
        if ( 0 == parsedLine ) {
            fprintf(stderr,"error parsing name: %s", line);
            return 0;
        }
        scanned = sscanf(parsedLine,"%X", &uni_char);
        
        if ( scanned ) {
            char *name = strtok(NULL, ";");
            
            if ( 0 == name ) {
                fprintf(stderr,"error parsing name: %s", line);
                goto cleanup;
            }
            
            if ( strstr(name, "Surrogate") )
                continue;
            
            if ( ! f_include_pua && strstr(name, "Private Use") )
                continue;
            
            // handle character range entries
            if ( strstr(name, "First>") ) {
                unsigned int rangeEnd;
                
                fgets(line, sizeof(line), uf);
                
                parsedLine = strtok(line, ";");
                if ( 0 == name ) {
                    fprintf(stderr,"error parsing name: %s", line);
                    goto cleanup;
                }
                scanned = sscanf(line,"%X", &rangeEnd);
                
                name = strtok(NULL, ";");
//                name = parse_unicode_char_name(line);
                
                if ( 0 == name )
                    goto cleanup;
                
                if ( 0 == strstr(name, "Last>") ) {
                    fprintf(stderr,"Expected range end, got: %s.", line);
                    
                    goto cleanup;
                }
                
                if (uni_char <= 0xFFFF && rangeEnd <= 0xFFFF) {
                    fprintf(stdout,"Expanding range from %04X - %04X.\n", uni_char, rangeEnd);

                    for (UChar32 j = uni_char; j <= rangeEnd ; j++ ) {
                        v_unicode.push_back(j);
                        cnt++;
                    }
                }
                else
                {
                    // TODO: Don't do the range check when Windows can properly handle surrogates.
                    fprintf(stdout, "Skipping range from %04X - %04X.\n", uni_char, rangeEnd);
                }
            }
            else
            {
                // TODO: Don't do the range check when Windows can properly handle surrogates.
                if (uni_char <= 0xFFFF) {
                    v_unicode.push_back(uni_char);
                    cnt++;
                }
            }
        } 
        else
            fprintf(stderr,"Line skipped: %s", line);
    }
    
    ret = v_unicode.size();
    
cleanup:
    fclose(uf);
    
    return ret;
}
*/

const char *getPremadeStateTable(cp_id cp) 
{
#ifdef WIN32
    /*
    These state tables are a combination between the IBM state tables,
    and what was generated by this program.  States that are valid in the
    IBM encodings should also be valid in microsoft.
    */
    static const struct encoding_state_table_entry {
        uint32_t cp;
        const char *state_table;
    } encoding_state_table[] = {
        {932,   // Shift-JIS
        "<icu:state>                   0-80, 81-9f:1, a0-df, e0-fc:1, fd-ff\n"
        "<icu:state>                   40-7e, 80-fc\n"
        },
        {936,   // gb2312
        "<icu:state>                   0-80, 81-fe:1, ff\n"
        "<icu:state>                   40-7e, 80-fe\n"
        },
        {950,   // Big-5
        "<icu:state>                   0-80, 81-fe:1, ff\n"
        "<icu:state>                   40-7e, 81-fe\n"
        },
        {10008, // Mac euc-cn
        "<icu:state>                   0-a0, a1-f7:1, f8-ff\n"
        "<icu:state>                   a1-fe\n"
        },
/*        {, // 
        "\n"
        "\n"
        },
        {, // 
        "\n"
        "\n"
        },
        {, // 
        "\n"
        "\n"
        },
        {, // 
        "\n"
        "\n"
        },
        {, // 
        "\n"
        "\n"
        },*/
        {51936, // GBK
        "# This is not euc-cn. This is GBK\n"
        "<icu:state>                   0-80, 81-fe:1, ff\n"
        "<icu:state>                   40-7e, 80-fe\n"
        },
        {51949, // euc-kr
        "<icu:state>                   0-80, a1-fe:1, ff\n"
        "<icu:state>                   a1-fe\n"
        },
/*        {, // 
        "\n"
        "\n"
        }*/
    };
    const int state_table_size = sizeof(encoding_state_table)/sizeof(encoding_state_table_entry);

    for (int idx = 0; idx < state_table_size; idx++) {
        if (cp == encoding_state_table[idx].cp) {
            return encoding_state_table[idx].state_table;
        }
    }
#endif

    return NULL;
}

int32_t getEncodingFeatures(map<UChar32, string> uni_to_cp, UBool used_PUA)
{
    uint32_t feature = 0;
    int32_t uni;

    if (uni_to_cp.size() < 0x7f) {
        fprintf(stdout, "Incomplete mapping\n");
        return ERR_UNKNOWN;
    }

    map<UChar32, string>::iterator letterAItr = uni_to_cp.find(0x41);
    map<UChar32, string>::iterator newlineItr = uni_to_cp.find(0x0A);

    if ( letterAItr == uni_to_cp.end() || newlineItr == uni_to_cp.end()) {
        fprintf(stdout, "Can't find A or \\n\n");
        return ERR_UNKNOWN;
    }

    string letterA = (*letterAItr).second;
    string newline = (*newlineItr).second;

    if(letterA[1] == 0) {
        if(letterA[0]==0x41) {
            feature |= ASCII;
        } else if(letterA[0]==0xc1) {
            feature |= EBCDIC;
        }
    }
    if(newline[1]==0) {
        if(newline[0]==0x25) {
            feature |= EBCDIC;
        } else if(newline[0]==0x15) {
            feature |= (EBCDIC | EBCDIC_NLLF);
        }
    }

    if ((feature & EBCDIC) == 0) {
        for (uni = 0; uni < 0x80; uni++) {
            map<UChar32, string>::iterator iter_cp = uni_to_cp.find(uni);

            if ( iter_cp == uni_to_cp.end() ) 
            {
                // Didn't map the normal part of ASCII. Something else must be here.
                feature |= VASCII;
                continue;
            }
            // is it a primary mapping or a fallback?
            string cp_data_uni_to_cp = (*iter_cp).second;
            uint8_t cp_byte = cp_data_uni_to_cp[0];
            if (cp_data_uni_to_cp[1] != 0) {
                feature |= VASCII;
            } else if (uni != cp_byte) {
                /* IBM PC rotation of SUB and other controls: 0x1a->0x7f->0x1c->0x1a */
                if (uni==0x1a && cp_byte==0x7f
                 || uni==0x1c && cp_byte==0x1a
                 || uni==0x7f && cp_byte==0x1c) {
                    feature |= (ASCII | VSUB);
                } else if (uni < 0x20 || uni == 0x7f) {
                    feature |= VCONTROLS;
                } else {
                    feature |= VASCII;
                }
            }
        }
    }

    if (used_PUA) {
        feature |= PRIVATE_USE;
    }
//    for (uni = 0xE000; uni < 0xF900; uni++) {
        // check for primary or fallback mapping (uni -> code page)
//        if ( uni_to_cp.find(uni) != uni_to_cp.end() ) 
//        {
//            feature |= PRIVATE_USE;
//            break;
//        }
//    }
    return feature;
}


// Generate input data for code page to Unicode conversion

void
get_strings(string str, byte_info_ptr byte_range, vector<string>& cp_data)
{
    for (int l = 0 ; l < 0x100 ; l++)
    {
        if ( byte_range->byte[l] == BYTE_INFO_END )
        {
            string final_str(str);
            
            final_str += (char) l;
            
            cp_data.push_back(final_str);
        }
        else if ( byte_range->byte[l] == BYTE_INFO_CONTINUE )
        {
            string new_str(str);
            
            new_str += (char) l;
            
            get_strings(new_str, byte_range+1, cp_data);
        }
    }
}

void 
gen_cp_strings(byte_info_ptr byte_range, vector<string>& cp_data)
{
    string start_str;
    
    get_strings(start_str, byte_range, cp_data);
}

// generate hex escape sequences for code page data in ucm format

string gen_hex_escape(string str)
{
    static char hex[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    string esc;
    char buff[8];
    const char *cstr = str.c_str();
    
    // quick fix - empty string really means one NULL
    
    if ( str.size() == 0 )
    {
        esc = "\\x00";
        return esc;
    }
    
    buff[0] = '\\';
    buff[1] = 'x';
    buff[4] = 0;
    for ( int i = 0 ; i < str.size() ; i++ )
    {
        unsigned char c = (unsigned char)str[i];
        buff[2] = hex[(c >> 4) & 0xF];
        buff[3] = hex[c & 0xF];
        
//        sprintf(buff, "\\x%02X", (unsigned char)cstr[i]);
        
        esc += buff;
    }
    
    return esc;
}


void emit_ucm_header(FILE* fp, cp_id cp, _encoding_info* encoding_info, const cp_info& cp_inf, int32_t features)
{
    unsigned int i = 0;
    time_t currTime;
    char timeBuf[64];
    char icuInfoBuf[1024];
    char code_page_str[32];
    
    sprintf(code_page_str, "%d", cp);
    
    time(&currTime);
    strftime(timeBuf, sizeof(timeBuf), "%b %d %H:%M %Z %Y", localtime(&currTime));
    
    fputs("# ***************************************************************************\n", fp);
    fputs("# *\n", fp);
    fputs("# *   Copyright (C) 2001, International Business Machines\n", fp);
    fputs("# *   Corporation and others.  All Rights Reserved.\n", fp);
    fputs("# *\n", fp);
    fputs("# ***************************************************************************\n", fp);
    fputs("#\n", fp);
    fprintf(fp, "# File created on %s\n", timeBuf);
    fputs("#\n", fp);
    fputs("# File created by genmlang tool.\n", fp);
    fprintf(fp, "# from %s %s using %s\n", OS_VENDOR, OS_VARIANT, OS_INTERFACE);
    fputs("#\n", fp);
    fputs("# Table Version : 1.0\n", fp);
    fputs("# The 1st column is the Unicode scalar value.\n", fp);
    fputs("# The 2nd column is the codepage byte sequence.\n", fp);
    fputs("# The 3rd column is the fallback indicator.\n", fp);
    fputs("# The fallback indicator can have one of the following values:\n", fp);
    fputs("#   |0 for exact 1-1 roundtrip mapping\n", fp);
    fputs("#   |1 for the best fallback codepage byte sequence.\n", fp);
    fputs("#   |2 for the substitution character\n", fp);
    fputs("#   |3 for the best reverse fallback Unicode scaler value\n", fp);
    fputs("#\n", fp);
    fprintf(fp, "# Encoding description: %s\n", encoding_info->charset_description);
    fprintf(fp, "# Encoding MIME name: %s\n", encoding_info->web_charset_name);
    fputs("#\n", fp);
    fprintf(fp, "<code_set_name>               \"%s-%s-%s\"\n", OS_VENDOR, code_page_str, OS_VARIANT);
    /* skip <char_name_mask>, no use for it */
    /* use memcmp later */
    fprintf(fp, "<mb_cur_max>                  %d\n", cp_inf.max_byte_size);
    /* SBCS and MBCS for now */
    fprintf(fp, "<mb_cur_min>                  %d\n", cp_inf.min_byte_size);
    fputs("<uconv_class>                 ", fp);
    if (cp_inf.max_byte_size <= 1) {
        fputs("\"SBCS\"\n", fp);
        fprintf(fp, "<subchar>                     \\x%02X\n", (unsigned char)cp_inf.default_char[0]);
        fputs(print_icu_features(icuInfoBuf, features, code_page_str), fp);
    } else {
        if (cp_inf.max_byte_size == 2 && cp_inf.min_byte_size == 2) {
            fputs("\"DBCS\"\n", fp);    // Might be dangerous because a certain EBCDIC state table is assumed!
        }
        else {
            fputs("\"MBCS\"\n", fp);
        }
        fputs("<subchar>                     ", fp);
        for (i = 0; i < strlen((char*)cp_inf.default_char); i++) {
            fprintf(fp, "\\x%02X", (unsigned char)cp_inf.default_char[i]);
        }
        fputs("\n", fp);
        fputs(print_icu_features(icuInfoBuf, features, code_page_str), fp);
        const char *premade_state_table = getPremadeStateTable(cp);
        if (premade_state_table) {
            fputs(premade_state_table, fp);
        }
        print_icu_state(cp_inf.byte_info, fp);
    }
    fputs("#\n", fp);
    fputs("CHARMAP\n", fp);
    fputs("#\n", fp);
    fprintf(fp, "#UNICODE CP%s\n", code_page_str);
    fputs("#_______ _________\n", fp);
}

void emit_ucm_tail(FILE* fp)
{
    /* emit ending */
    fputs("#\n", fp);
    fputs("END CHARMAP\n", fp);
    fputs("#\n", fp);
}


const char *print_icu_features(char *featureBuf, int32_t features, char* code_page_str)
{
    const char *charset_family = NULL;
    char buffer[256];

    if (features & ASCII) {
        charset_family = "ASCII";
    } else if (features & EBCDIC) {
        charset_family = "EBCDIC";
    }
    if (charset_family) {
        sprintf(featureBuf, "<icu:charsetFamily>           \"%s\"\n", charset_family);
    }
    else {
        sprintf(featureBuf, "# Unknown <icu:charsetFamily>\n");
    }
    sprintf(buffer, "# Suggested ICU specific alias information\n#<icu:alias>                  \"windows-%s", code_page_str);
    if ((features & (VASCII | EBCDIC_NLLF | PRIVATE_USE | VCONTROLS | VSUB)) == 0) {
        strcat(buffer, "_STD");
    } else {
        /* add variant indicators in alphabetic order */
        if (features & VASCII) {
            strcat(buffer, "_VASCII");
        }
        if (features & VCONTROLS) {
            strcat(buffer, "_VGCTRL");
        }
        if (features & EBCDIC_NLLF) {
            strcat(buffer, "_VLF");
        }
        if (features & VSUB) {
            strcat(buffer, "_VSUB");
        }
        if (features & PRIVATE_USE) {
            strcat(buffer, "_VPUA");
        }
    }
    strcat(buffer, "\"\n\n");
    strcat(featureBuf, buffer);
    return featureBuf;
}

char* gen_ucm_filename(cp_id cp)
{
    static char buff[80];
    
#ifdef _WIN32
    sprintf(buff, OS_VENDOR "-%d-" OS_VARIANT, cp);
#endif
    
    return buff;
}

FILE *open_ucm(char* p_ucm_filename)
{
    char name[80];
    
    strcpy(name, p_ucm_filename);
    strcat(name, ".ucm");
    
    return fopen(name, "wt");
}

// emit text for <icu:state> entries in ucm

void
print_icu_state(byte_info_ptr info, FILE* fp)
{
    fputs("\n# The following was the generated state table.\n# This does not account for unassigned characters\n" ,fp);
    for (int i = 0; i < MAX_BYTE_LEN && print_ranges(info->byte, 0x100, 1, i, fp); i++, info++ )
    {
    }
}

UBool print_ranges(int8_t arr[], size_t len, int print_threshold, int level, FILE* fp)
{
    typedef pair<int, int> pr;
    vector<pr> v_ranges;
    
    pair<int, int> p(0, 0);
    int i;
    int last_val = arr[0];
    
    for ( i = 1 ; i < len ; i++ )
    {
        if ( last_val == arr[i] )
            p.second = i;
        else
        {
            v_ranges.push_back(p);
            p.first = i;
            p.second = i;
        }
        
        last_val = arr[i];
    }
    
    v_ranges.push_back(p);
    
    // now print the ranges in icu:state style if there are any ranges to print
    
    int num_printed = 0;
    int vrange_size = v_ranges.size();
    
    for ( i = 0; i < vrange_size; i++ )
    {
        p = v_ranges[i];
        
        if ( arr[p.first] < print_threshold )
            continue;
        
        if ( num_printed )
            fprintf(fp, ", ");
        else
            fprintf(fp, "%-30s","#<icu:state>");
        
        if ( p.first == p.second )
            fprintf(fp, "%x", p.first);
        else
            fprintf(fp, "%x-%x", p.first, p.second);
        
        num_printed++;
        
        if ( arr[p.first] > 1 )
            fprintf(fp, ":%d", level+1);
    }
    
    if ( num_printed )
        fputs("\n", fp);
    return (UBool)(num_printed != 0);
}

void 
save_byte_range(byte_info_ptr byte_info, string str, size_t offset, size_t size)
{
    
    if ( offset < size )
    {
        uint8_t c = (uint8_t)str[offset];
        
        if ( (offset + 1) < size ) 
        {
            if (byte_info->byte[c] == BYTE_INFO_END)
            {
                // You have a stateful encoding like ISCII, iso-2022, hz, EBCDIC_STATEFUL
                fprintf(stderr, "\n Overwriting state info at %X ", c);
            }
            byte_info->byte[c] = BYTE_INFO_CONTINUE;
            
            save_byte_range(byte_info+1, str, offset+1, size);
        }
        else
        {
            byte_info->byte[c] = BYTE_INFO_END; 
        }
        
    }
    
}
